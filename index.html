<!doctype html>
<html>
<head>
	<title></title>
	<meta charset="UTF-8">
	<script type="text/javascript" src="js/modernizr-latest.js"></script>
	<script type="text/javascript">
		function tetrisGame(){
			var gamePaused = false, gameStarted = false, gameSpeed = 1000, gameScore = 0, gameLevel=1, gameMap = [], d = document;
			var gameLines = 20; gameColumns = 10, gameObjects = [];
			var gameStage = d.getElementById('gameStage'), ctx = gameStage.getContext("2d");
			var listObjects = [];
			var piecesUnit = 34, borderWidth = 5;
			var canvasWidth = (gameColumns*(piecesUnit-borderWidth))+borderWidth;
			var canvasHeight = (gameLines*(piecesUnit-borderWidth))+borderWidth;
			
			function getRandomNumber(limit){
				return Math.floor(Math.random()*limit);
			}//END FUNCTION
			
			function getRandomObject(){
				var len = gameObjects.length;
				if(!isNaN(len) && len>0){
					var obj = new gameObjects[getRandomNumber(len)](4,0,ctx);
					obj.setListIndex(listObjects.length);
					listObjects.push(obj);
					return obj;
				}//END IF
				return false;
			}//END FUNCTION
			
			function Point(x,y,color,ctx,obj){
				this.color = color;
				this.posX = x;
				this.posY = y;
				this.ctx = ctx;
				this.callerPiece = obj;
				this.setColor = function(c){
					this.color = c;
					return this;
				}//END FUNCTION
				this.setPosX = function(x){
					this.posX = x;
					return this;
				}//END FUNCTION
				this.setPosY = function(y){
					this.posY = y;
					return this;
				}//END FUNCTION
				this.draw = function(){
					var tempX = this.posX*(piecesUnit-borderWidth),tempY = this.posY*(piecesUnit-borderWidth);
					this.ctx.beginPath();
					this.ctx.fillStyle = "#000";
					this.ctx.fillRect(tempX,tempY,piecesUnit,piecesUnit);
					this.ctx.fillStyle = this.color;
					this.ctx.fillRect(tempX+borderWidth,tempY+borderWidth,piecesUnit-(borderWidth*2),piecesUnit-(borderWidth*2));
					this.ctx.closePath();
					gameMap[this.posX][this.posY] = this;
					return this;
				}//END FUNCTION
				this.clear = function(){
					var x = this.posX, y = this.posY;
					var tempX = x*(piecesUnit-borderWidth),tempY = y*(piecesUnit-borderWidth);
					this.ctx.clearRect(tempX,tempY,piecesUnit,piecesUnit);
					gameMap[x][y] = 0;
					return this;
				}//END FUNCTION
			}//END FUCNTION
			
			function Piece(){
				this.color = "#fff";
				this.ctx = null;
				this.listIndex = 0;
				this.rotateNumber = 0;
				this.points = new Array(4);
				this.isLeftBlock = false;
				this.isRightBlock = false;
				this.isBlock = false;
				this.setRotateNumber = function(n){
					this.rotateNumber = n;
					return this;
				}//END FUNCTION
				this.getRotateNumber = function(){
					return this.rotateNumber;
				}//END FUNCTION
				this.getListIndex = function(){
					return this.listIndex;
				}//END FUNCTION
				this.setListIndex = function(i){
					this.listIndex = i;
					return this;
				}//END FUNCTION
				this.getPoints = function(){
					return this.points;
				}//END FUNCTION
				this.setPoints = function(p){
					this.points = p;
					return this;
				}//END FUNCTION
				this.getContext = function(){
					return this.ctx;
				}//END FUNCTION
				this.setContext = function(ctx){
					this.ctx = ctx;
					return this;
				}//END FUNCTION
				this.getColor = function(){
					return this.color;
				}//END FUNCTION
				this.setColor = function(c){
					this.color = c;
					return this;
				}//END FUNCTION
				this.checkCollision = function(arrayPoints){
					for(var x in arrayPoints){
						var p = arrayPoints[x], _posX = p[0], _posY = p[1];
						var _index = this.getListIndex(); 
						if(_index>0){
							var point = gameMap[_posX][_posY];
							if((point instanceof Point) && point.callerPiece!==this){
								this.isBlock = true;
								return false;
							}//END IF
							/*for(var i=_index-1;i>=0;i--){
								var o = listObjects[i], _p = o.points;
								for(var y in _p){
									var oP = _p[y];
									if(oP[0]==_posX && oP[1]==_posY){
										this.isBlock = true;
										return false;
									}//END IF
								}//END FOR
							}//END FOR*/
						}//END IF
						
						this.isBlock = _posY>=gameLines;
						this.isLeftBlock = _posX<=-1;
						this.isRightBlock = _posX>=gameColumns;
						
						if(this.isBlock || this.isLeftBlock || this.isRightBlock){
							return false;
						}//END IF
					}//END FOR
					return true;
				}//END FUNCTION
				this.moveDown = function(v){
					var tempP = [] ,unit = v || 1;
					if(!this.isBlock){
						for(var i in this.points){
							var p = this.points[i];
							tempP.push([p[0],p[1]+unit]);
						}//END FOR
						if(this.checkCollision(tempP)){
							this.clear().setPoints(tempP).draw();
						}//END IF
					}//END IF
					return this;
				}//END FUNCTION
				this.moveLeft = function(v){
					var tempP = [] ,unit = v || 1;
					if(!this.isBlock && !this.isLeftBlock){
						for(var i in this.points){
							var p = this.points[i];
							tempP.push([p[0]-unit,p[1]]);
						}//END FOR
						if(this.checkCollision(tempP)){
							this.clear().setPoints(tempP).draw();
						}//END IF
					}//END IF
					return this;
				}//END FUNCTION
				this.moveRight = function(v){
					var tempP = [] ,unit = v || 1;
					if(!this.isBlock && !this.isRightBlock){ 	
						for(var i in this.points){
							var p = this.points[i];
							tempP.push([p[0]+unit,p[1]]);
						}//END FOR
						if(this.checkCollision(tempP)){
							this.clear().setPoints(tempP).draw();
						}//END IF
					}//END IF
					return this;
				}//END FUNCTION
				this.checkGameMapPointsRender = function(x,y,obj){
					if(x>=0 && x<gameColumns && y>=0 && y<gameLines){
						var p = gameMap[x][y];
						if(p instanceof Point && p.callerPiece!==obj){
							p.draw();
						}//END IF
					}//END IF
				}//END FUNCTION
				this.clear = function(){
					for(var x in this.points){
						var p = this.points[x],tempX = p[0]*(piecesUnit-borderWidth),tempY = p[1]*(piecesUnit-borderWidth);
						gameMap[p[0]][p[1]] = 0;
						ctx.clearRect(tempX,tempY,piecesUnit,piecesUnit);
						this.checkGameMapPointsRender(p[0]+1,p[1],this);
						this.checkGameMapPointsRender(p[0]-1,p[1],this);
						this.checkGameMapPointsRender(p[0],p[1]+1,this);
						this.checkGameMapPointsRender(p[0],p[1]-1,this);
					}//END FOR
					return this;
				}//END FUNCTION
				this.draw = function(){
					var p = this.points, len = p.length;
					if(len>0){
						for(var i=0;i<len;i++){
							var x = p[i][0], y = p[i][1];
							(new Point(p[i][0],p[i][1],this.color,this.ctx,this)).draw();
						}//END FOR
					}//END IF
				}//END FUNCTION
				this.rotate90 = function(){
					//abstract method
				}//END FUNCTION
			}//END FUNCTION
			
			function Reta(x,y,ctx){
				this.setColor("#FF6600").setContext(ctx).setPoints([[x,y],[x,y+1],[x,y+2],[x,y+3]]).draw();
				this.rotate90 = function(){
					var rn = this.getRotateNumber(), p = this.getPoints()[1];
					var x = p[0], y = p[1];
					switch(rn){
						case 0:
							this.clear().setPoints([[x-1,y],[x,y],[x+1,y],[x+2,y]]).draw();
							break;
						case 1:
							this.clear().setPoints([[x,y-1],[x,y],[x,y+1],[x,y+2]]).draw();
							break;
					}//END SWITCH
					this.rotateNumber = (!rn%2);
				}//END IF
			}//END FUNCTION
			Reta.prototype = new Piece();
			gameObjects.push(Reta);
			
			function Quadrado(x,y,ctx){
				this.setColor("#f00").setContext(ctx).setPoints([[x,y],[x+1,y],[x,y+1],[x+1,y+1]]).draw();
			}//END FUNCTION
			Quadrado.prototype = new Piece();
			gameObjects.push(Quadrado);
			
			function BlocoAzul(x,y,ctx){
				this.setColor("#66CCFF").setContext(ctx).setPoints([[x,y],[x+1,y],[x,y+1],[x-1,y+1]]).draw();
				this.rotate90 = function(){
					var rn = this.getRotateNumber(), p = this.getPoints()[0];
					var x = p[0], y = p[1];
					switch(rn){
						case 0:
							this.clear().setPoints([[x,y],[x,y+1],[x+1,y+1],[x+1,y+2]]).draw();
							break;
						case 1:
							this.clear().setPoints([[x,y],[x+1,y],[x,y+1],[x-1,y+1]]).draw();
							break;
					}//END SWITCH
					this.rotateNumber = (!rn%2);
				}//END FUNCTION
			}//END FUNCTION
			BlocoAzul.prototype = new Piece();
			gameObjects.push(BlocoAzul);
			
			function BlocoVerde(x,y,ctx){
				this.setColor("#00FF00").setContext(ctx).setPoints([[x,y],[x-1,y],[x,y+1],[x+1,y+1]]).draw();
				
				this.rotate90 = function(){
					var rn = this.getRotateNumber(), p = this.getPoints()[0];
					var x = p[0], y = p[1];
					switch(rn){
						case 0:
							this.clear().setPoints([[x,y],[x,y+1],[x+1,y],[x+1,y-1]]).draw();
							break;
						case 1:
							this.clear().setPoints([[x,y],[x-1,y],[x,y+1],[x+1,y+1]]).draw();
							break;
					}//END SWITCH
					this.rotateNumber = (!rn%2);
				}//END FUNCTION
				
			}//END FUNCTION
			BlocoVerde.prototype = new Piece();
			gameObjects.push(BlocoVerde);
			
			function BlocoAmarelo(x,y,ctx){
				this.setColor("#FFFF00").setContext(ctx).setPoints([[x,y],[x,y+1],[x+1,y+1],[x-1,y+1]]).draw();
				
				this.rotate90 = function(){
					var rn = this.getRotateNumber(), p = this.getPoints()[0];
					var x = p[0], y = p[1];
					switch(rn){
						case 0:
							this.clear().setPoints([[x,y],[x,y+1],[x+1,y+1],[x,y+2]]).draw();
							break;
						case 1:
							this.clear().setPoints([[x,y],[x-1,y],[x+1,y],[x,y+1]]).draw();
							break;
						case 2:
							this.clear().setPoints([[x,y],[x,y+1],[x-1,y+1],[x,y+2]]).draw();
							break;
						case 3:
							this.clear().setPoints([[x,y],[x,y+1],[x+1,y+1],[x-1,y+1]]).draw();
							break;
					}//END SWITCH
					this.rotateNumber = (++rn>3)?0:rn;
				}//END FUNCTION
				
			}//END FUNCTION
			BlocoAmarelo.prototype = new Piece();
			gameObjects.push(BlocoAmarelo);
			
			function BlocoRosa(x,y,ctx){
				this.setColor("#CC00FF").setContext(ctx).setPoints([[x,y],[x+1,y],[x,y+1],[x,y+2]]).draw();
				
				this.rotate90 = function(){
					var rn = this.getRotateNumber(), p = this.getPoints()[0];
					var x = p[0], y = p[1];
					switch(rn){
						case 0:
							this.clear().setPoints([[x,y],[x-1,y],[x+1,y],[x+1,y+1]]).draw();
							break;
						case 1:
							this.clear().setPoints([[x,y],[x,y+1],[x,y+2],[x-1,y+2]]).draw();
							break;
						case 2:
							this.clear().setPoints([[x,y],[x-1,y],[x+1,y],[x-1,y-1]]).draw();
							break;
						case 3:
							this.clear().setPoints([[x,y],[x+1,y],[x,y+1],[x,y+2]]).draw();
							break;
					}//END SWITCH
					this.rotateNumber = (++rn>3)?0:rn;
				}//END FUNCTION
				
			}//END FUNCTION
			BlocoRosa.prototype = new Piece();
			gameObjects.push(BlocoRosa);
			
			function BlocoAzulEscuro(x,y,ctx){
				this.setColor("#0000FF").setContext(ctx).setPoints([[x,y],[x-1,y],[x,y+1],[x,y+2]]).draw();
				
				this.rotate90 = function(){
					var rn = this.getRotateNumber(), p = this.getPoints()[0];
					var x = p[0], y = p[1];
					switch(rn){
						case 0:
							this.clear().setPoints([[x,y],[x-1,y],[x+1,y],[x+1,y-1]]).draw();
							break;
						case 1:
							this.clear().setPoints([[x,y],[x,y+1],[x,y+2],[x+1,y+2]]).draw();
							break;
						case 2:
							this.clear().setPoints([[x,y],[x+1,y],[x-1,y],[x-1,y+1]]).draw();
							break;
						case 3:
							this.clear().setPoints([[x,y],[x-1,y],[x,y+1],[x,y+2]]).draw();
							break;
					}//END SWITCH
					this.rotateNumber = (++rn>3)?0:rn;
				}//END FUNCTION
			}//END FUNCTION
			BlocoAzulEscuro.prototype = new Piece();
			gameObjects.push(BlocoAzulEscuro);
			
			function removeLine(lineIndex){
				for(var i=0;i<gameColumns;i++){
					var p = gameMap[i][lineIndex];
						p.clear();
				}//END FOR
				
				for(var i=lineIndex-1;i>=0;i--){
					for(var j=0;j<gameColumns;j++){
						var p = gameMap[j][i];
						if(!(p instanceof Point)){
							continue;
						}else{
							p.clear().setPosX(j).setPosY(i+1).draw();
						}//END IF
					}//END FOR
				}//END FOR
				
			}//END FUNCTION
			
			function checkLineCompleted(){
				linesloop:
				for(var i = gameLines-1;i>=0;i--){
					for(var j = 0; j<gameColumns;j++){
						var p = gameMap[j][i];
						if(!(p instanceof Point)){
							continue linesloop;
						}else if(j==gameColumns-1){
							removeLine(i);
							return checkLineCompleted();
						}//END IF
					}//END FOR
				}//END FOR
			}//END FUNCTION
			
			function addEvent(obj,evt,callback){
				if(obj.addEventListener){
					obj.addEventListener(evt,callback,false);
				}else if(obj.attachEvent){
					obj.attachEvent("on"+evt,callback);
				}//END IF
			}//END FUNCTION
			
			this.run = function(){
				gameStage.setAttribute("width",canvasWidth);
				gameStage.setAttribute("height",canvasHeight);
				gameStage.setAttribute("style","border: solid 1px red;");
				
				for(var x=0;x<gameColumns;x++){
					gameMap[x] = [];
					for(var y=0;y<gameLines;y++){
						gameMap[x][y] = 0;
					}//END FOR
				}//END FOR
				
				addEvent(window,"keydown",function(event){
					var keyCode = event.keyCode;
					switch(keyCode){
						case 0x25:
							if(!gamePaused){
								_currentObject.moveLeft();
							}//END IF
							break;
						case 0x26:
							if(!gamePaused){
								_currentObject.rotate90();
							}//END IF
							break;
						case 0x27:
							if(!gamePaused){
								_currentObject.moveRight();
							}//END IF
							break;
						case 0x28:
							if(!gamePaused){
								_currentObject.moveDown();
							}//END IF
							break;
						case 0x50:
							gamePaused = true;
							clearInterval(interval);
							break;
						default:
							break;
					}//END SWITCH
				});
				
				ctx.lineWidth = borderWidth;
				ctx.strokeStyle = "#0f0";
				
				var _currentObject = getRandomObject();
				var interval = setInterval(function(){
					_currentObject.moveDown();
					if(_currentObject.isBlock){
						checkLineCompleted();
						_currentObject = getRandomObject();
					}//END IF
				},gameSpeed);
				
			}//END FUNCTION
		}//END FUNCTION
		
		window.onload = function(){
			if(Modernizr.canvas){//verifica feature do Canvas
				var app = new tetrisGame();
					app.run();
			}//END IF
		}//END FUNCTION
	</script>
</head>
<body>
	<div id="gameWrapper">
		<canvas id="gameStage">Seu Browser não oferece suporte a esta tecnologia.</canvas>
	</div>
</body>
</html>